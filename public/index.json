[{"categories":["Web"],"content":"渲染页面：浏览器的工作原理 在浏览网页时用户希望页面的内容能够快速加载且流畅交互。因此，开发者应力争实现这两个目标。 理解浏览器的工作原理有助于开发者了解该如何提升性能和感知性能。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:0:0","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"概述 快速响应的网站提供更好的用户体验。用户期待内容快速加载和流畅交互的 Web 体验。 导致 Web 性能问题的原因主要有两种，一是网络延迟，二是大部分情况下的浏览器单线程执行。 保障页面快速加载的最大威胁是网络延迟。开发者的目标是使网站加载速度尽可能快，或者至少看起来加载速度很快，以便用户尽快获取所需信息。网络延迟是将字节传输到计算机的时间。Web 性能优化需要做的就是使页面尽可能快地加载完成。 大部分情况下，浏览器被认为是单线程的。也就是说，它们在执行一个任务之前会从头到尾完成一个任务，然后才会接受另一个任务。为了实现流畅的交互，开发者的目标是确保网站的交互性能良好，从流畅的滚动到对触摸的响应。渲染时间非常关键，我们需要确保主线程能够完成交给它的所有工作，并且始终能够处理用户交互。通过理解浏览器的单线程特性，并尽可能和适当地减少主线程的责任，可以提高网页性能，以确保渲染流畅，并且对交互的响应是即时的。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:1:0","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"导航 导航是加载 web 页面的第一步。它发生在以下情形：用户通过在地址栏输入一个 URL、点击一个链接、提交表单或者是其他的行为。 Web 性能优化的目标之一就是缩短导航完成所花费的时间，在理想情况下，它通常不会花费太多的时间，但是网络延迟和带宽会让它变久。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:2:0","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"DNS 查询 对于一个 web 页面来说导航的第一步是要去寻找页面资源的位置。如果导航到 https://example.com，HTML 页面被定位到 IP 地址为 93.184.216.34 的服务器。如果以前没有访问过这个网站，就需要进行 DNS 查询。 浏览器向域名服务器发起 DNS 查询请求，最终得到一个 IP 地址。第一次请求之后，这个 IP 地址可能会被缓存一段时间，这样可以通过从缓存里面检索 IP 地址而不是再通过域名服务器进行查询来加速后续的请求。 每个主机名 (hostname) 在页面加载时通常只需要进行一次 DNS 查询。但是，对于页面指向的不同的主机名，则需要多次 DNS 查询。如果字体（font）、图像（image）、脚本（script）、广告（ads）和网站统计（metric）都有不同的主机名，则需要对每一个主机名进行 DNS 查询。 但是对于移动网络，DNS 查询可能存在性能问题。当一个用户使用移动网络时，所有 DNS 查询必须从手机发送到基站，然后到达一个权威 DNS 服务器。手机、信号塔、域名服务器之间的距离会显著增加延迟。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:2:1","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"TCP 握手 一旦获取到服务器 IP 地址，浏览器就会通过TCP“三次握手”与服务器建立连接。这个机制的是用来让两端尝试进行通信——在浏览器和服务器通过上层协议 HTTPS 发送数据之前，可以协商网络 TCP 套接字连接的一些参数。 TCP 的“三次握手”技术经常被称为“SYN-SYN-ACK”——更确切的说是 SYN、SYN-ACK、ACK——因为通过 TCP 首先发送了三个消息进行协商，然后在两台电脑之间开始一个 TCP 会话。是的，这意味着当请求尚未发出的时候，终端与每台服务器之间还要来回多发送三条消息。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:2:2","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"TLS 协商 对于通过 HTTPS 建立的安全连接，还需要另一次 “握手”。这种握手，或者说 TLS 协商，决定使用哪种密码对通信进行加密，验证服务器，并在开始实际数据传输前建立安全连接。这就需要在实际发送内容请求之前，再往返服务器五次。 虽然建立安全连接的步骤增加了等待加载页面的时间，但是为了建立一个安全的连接而增加延迟是值得的，因为在浏览器和 web 服务器之间传输的数据不可以被第三方解密。 如此经过 8 次往返，浏览器终于可以发出请求。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:2:3","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"响应 一旦我们建立了和 web 服务器的连接，浏览器就会代表用户发送一个初始的 HTTP GET 请求，对于网站来说，这个请求通常是一个 HTML 文件。一旦服务器收到请求，它将使用相关的响应头和 HTML 的内容进行回复。 HTMLCopy to Clipboard \u003c!doctype html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003ctitle\u003e简单的页面\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"styles.css\" /\u003e \u003cscript src=\"myscript.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 class=\"heading\"\u003e我的页面\u003c/h1\u003e \u003cp\u003e含有\u003ca href=\"https://example.com/about\"\u003e链接\u003c/a\u003e的段落。\u003c/p\u003e \u003cdiv\u003e \u003cimg src=\"myimage.jpg\" alt=\"图像描述\" /\u003e \u003c/div\u003e \u003cscript src=\"anotherscript.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 初始请求的响应包含所接收数据的第一个字节。首字节时间（TTFB）是用户通过点击链接进行请求与收到第一个 HTML 数据包之间的时间。第一个内容分块通常是 14KB 的数据。 上面的示例中，这个请求肯定是小于 14KB 的，但是直到浏览器在解析阶段遇到链接时才会去请求链接的资源，下面有进行描述。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:3:0","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"拥塞控制 / TCP 慢启动 在传输过程中，TCP 包被分割成段。由于 TCP 保证了数据包的顺序，因此服务器在发送一定数量的分段后，必须从客户端接收一个 ACK 包的确认。 如果服务器在发送每个分段之后都等待 ACK，那么客户端将频繁地发送 ACK，并且可能会增加传输时间，即使在网络负载较低的情况下也是如此。 另一方面，一次发送过多的分段会导致在繁忙的网络中客户端无法接收分段并且长时间地只会持续发送 ACK，服务器必须不断重新发送分段的问题。 为了平衡传输分段的数量，TCP 慢启动算法用于逐渐增加传输数据量，直到确定最大网络带宽，并在网络负载较高时减少传输数据量。 传输段的数量由拥塞窗口（CWND）的值控制，该值可初始化为 1、2、4 或 10 MSS（以太网协议中的 MSS 为 1500 字节）。该值是发送的字节数，客户端收到后必须发送 ACK。 如果收到 ACK，那么 CWND 值将加倍，这样服务器下次就能发送更多的数据分段。相反，如果没有收到 ACK，那么 CWND 值将减半。因此，这种机制在发送过多分段和过少分段之间取得了平衡。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:3:1","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"解析 一旦浏览器收到第一个数据分块，它就可以开始解析收到的信息。“解析”是浏览器将通过网络接收的数据转换为 DOM 和 CSSOM 的步骤，通过渲染器在屏幕上将它们绘制成页面。 虽然 DOM 是浏览器标记的内部表示，但是它也被暴露出来，可以通过 JavaScript 中的各种 API 进行操作。 即使请求页面的 HTML 大于初始的 14KB 数据包，浏览器也将根据其拥有的数据开始解析并尝试渲染。这就是为什么在前 14KB 中包含浏览器开始渲染页面所需的所有内容，或者至少包含页面模板（第一次渲染所需的 CSS 和 HTML）对于 web 性能优化来说是重要的。但是在渲染到屏幕上面之前，HTML、CSS、JavaScript 必须被解析完成。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:4:0","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"构建 DOM 树 我们在关键渲染路径这篇文章中描述了五个步骤。 第一步是处理 HTML 标记并构造 DOM 树。HTML 解析涉及到符号化和树的构造。HTML 标记包括开始和结束标记，以及属性名和值。如果文档格式良好，则解析它会简单而快速。解析器将标记化的输入解析到文档中，构建文档树。 DOM 树描述了文档的内容。`` 元素是第一个标签也是文档树的根节点。树反映了不同标记之间的关系和层次结构。嵌套在其他标记中的标记是子节点。DOM 节点的数量越多，构建 DOM 树所需的时间就越长。 当解析器发现非阻塞资源，例如一张图片，浏览器会请求这些资源并且继续解析。当遇到一个 CSS 文件时，解析也可以继续进行，但是对于 \u003cscript\u003e 标签（特别是没有 async 或者 defer 属性的）会阻塞渲染并停止 HTML 的解析。尽管浏览器的预加载扫描器加速了这个过程，但过多的脚本仍然是一个重要的瓶颈。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:4:1","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"预加载扫描器 浏览器构建 DOM 树时，这个过程占用了主线程。同时，预加载扫描器会解析可用的内容并请求高优先级的资源，如 CSS、JavaScript 和 web 字体。多亏了预加载扫描器，我们不必等到解析器找到对外部资源的引用时才去请求。它将在后台检索资源，而当主 HTML 解析器解析到要请求的资源时，它们可能已经下载中了，或者已经被下载。预加载扫描器提供的优化减少了阻塞。 HTMLCopy to Clipboard \u003clink rel=\"stylesheet\" href=\"styles.css\" /\u003e \u003cscript src=\"myscript.js\" async\u003e\u003c/script\u003e \u003cimg src=\"myimage.jpg\" alt=\"图像描述\" /\u003e \u003cscript src=\"anotherscript.js\" async\u003e\u003c/script\u003e 在这个例子中，当主线程在解析 HTML 和 CSS 时，预加载扫描器将找到脚本和图像，并开始下载它们。为了确保脚本不会阻塞进程，当 JavaScript 解析和执行顺序不重要时，可以添加 async 属性或 defer 属性。 等待获取 CSS 不会阻塞 HTML 的解析或者下载，但是它确实会阻塞 JavaScript，因为 JavaScript 经常用于查询元素的 CSS 属性。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:4:2","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"构建 CSSOM 树 第二步是处理 CSS 并构建 CSSOM 树。CSS 对象模型和 DOM 是相似的。DOM 和 CSSOM 是两棵树。它们是独立的数据结构。浏览器将 CSS 规则转换为可以理解和使用的样式映射。浏览器遍历 CSS 中的每个规则集，根据 CSS 选择器创建具有父、子和兄弟关系的节点树。 与 HTML 类似，浏览器需要将接收到的 CSS 规则转换为可处理的格式。因此，它重复了 HTML 到对象的过程，但这次是针对 CSS。 CSSOM 树包括来自用户代理样式表的样式。浏览器从适用于节点的最通用规则开始，并通过应用更具体的规则递归地优化计算的样式。换句话说，它级联属性值。 构建 CSSOM 非常快，并且在当前的开发工具中没有以独特的颜色显示。相反，开发人员工具中的“重新计算样式”显示解析 CSS、构建 CSSOM 树和递归计算计算样式所需的总时间。在 web 性能优化方面，它是可轻易实现的，因为创建 CSSOM 的总时间通常小于一次 DNS 查询所需的时间。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:4:3","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"其他过程 JavaScript 编译 在解析 CSS 和创建 CSSOM 的同时，包括 JavaScript 文件在内的其他资源也在下载（这要归功于预加载扫描器）。JavaScript 会被解析、编译和解释。脚本被解析为抽象语法树。有些浏览器引擎会将抽象语法树输入编译器，输出字节码。这就是所谓的 JavaScript 编译。大部分代码都是在主线程上解释的，但也有例外，例如在 web worker 中运行的代码。 构建无障碍树 浏览器还构建辅助设备用于分析和解释内容的无障碍树。无障碍对象模型（AOM）类似于 DOM 的语义版本。当 DOM 更新时，浏览器会更新辅助功能树。辅助技术本身无法修改无障碍树。 在构建 AOM 之前，屏幕阅读器无法访问内容。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:4:4","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"渲染 渲染步骤包括样式、布局、绘制，在某些情况下还包括合成。在解析步骤中创建的 CSSOM 树和 DOM 树组合成一个渲染树，然后用于计算每个可见元素的布局，然后将其绘制到屏幕上。在某些情况下，可以将内容提升到它们自己的层并进行合成，通过在 GPU 而不是 CPU 上绘制屏幕的一部分来提高性能，从而释放主线程。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:5:0","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"样式 关键呈现路径的第三步是将 DOM 和 CSSOM 组合成渲染树。计算样式树或渲染树的构建从 DOM 树的根开始，遍历每个可见节点。 不会被显示的元素，如 `` 元素及其子元素，以及任何带有 display: none 的节点，如用户代理样式表中的 script { display: none; }，都不会包含在渲染树中，因为它们不会出现在渲染输出中。应用了 visibility: hidden 的节点会包含在渲染树中，因为它们会占用空间。由于我们没有给出任何指令来覆盖用户代理默认值，因此上述代码示例中的 script 节点不会包含在渲染树中。 每个可见节点都应用了 CSSOM 规则。渲染树包含所有可见节点的内容和计算样式，将所有相关样式与 DOM 树中的每个可见节点匹配起来，并根据 CSS 级联，确定每个节点的计算样式。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:5:1","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"布局 第四步是在渲染树上运行布局以计算每个节点的几何体。布局是确定呈现树中所有节点的尺寸和位置，以及确定页面上每个对象的大小和位置的过程。重排是后续过程中对页面的任意部分或整个文档的大小和位置的重新计算。 渲染树构建完毕后，浏览器就开始布局。渲染树标识了哪些节点会显示（即使不可见）及其计算样式，但不标识每个节点的尺寸或位置。为了确定每个对象的确切大小和位置，浏览器会从渲染树的根开始遍历。 在网页上，大多数东西都是一个盒子。不同的设备和不同的桌面设置意味着无限数量的不同视区大小。在此阶段，根据视口大小，浏览器将确定屏幕上所有盒子的大小。以视口大小为基础，布局通常从 body 开始，设置所有 body 后代的大小，同时给不知道其尺寸的替换元素（例如图像）提供占位符空间，空间大小以相应元素盒模型的属性为准。 第一次确定每个节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为重排。在我们的示例中，假设初始布局发生在返回图像之前。由于我们没有声明图像的尺寸，因此一旦知道图像的尺寸，就会出现重排。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:5:2","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"绘制 关键渲染路径中的最后一步是将各个节点绘制到屏幕上，其中第一次的绘制被称为首次有意义的绘制。在绘制或光栅化阶段，浏览器将在布局阶段计算的每个盒子转换为屏幕上的实际像素。绘制涉及将元素的每个可见部分绘制到屏幕上，包括文本、颜色、边框、阴影以及按钮和图像等替换元素。浏览器需要以超快的速度执行这个过程。 为了确保平滑滚动和动画效果，包括计算样式、回流和绘制等占用主线程的所有操作，必须在不超过 16.67 毫秒的时间内完成。在 2048 x 1536 分辨率下，iPad 需要将超过 314.5 万个像素绘制到屏幕上。这是非常多的像素，必须要非常快速地绘制出来。为了确保重绘能够比初始绘制更快地完成，绘制到屏幕的操作通常被分解成几个图层。如果发生这种情况，浏览器则需要进行合成。 绘制可以将布局树中的元素分解为多个层。将内容提升到 GPU 上的层（而不是 CPU 上的主线程）可以提高绘制和重新绘制性能。有一些特定的属性和元素可以实例化一个层，包括 ](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video) 和 [，任何 CSS 属性为 opacity 、3D transform、will-change 的元素，还有一些其他元素。这些节点将与子节点一起绘制到它们自己的层上，除非子节点由于上述一个（或多个）原因需要自己的层。 分层确实可以提高性能，但在内存管理方面成本较高，因此不应作为 Web 性能优化策略的过度使用。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:5:3","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"合成 当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。 当页面继续加载资源时，可能会发生回流（回想一下我们迟到的示例图像），回流会触发重新绘制和重新合成。如果我们定义了图像的大小，就不需要重新绘制，只需要绘制需要重新绘制的层，并在必要时进行合成。但我们并没有定义图像大小！所以从服务器获取图像后，渲染过程将返回到布局步骤并从那里重新开始。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:5:4","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["Web"],"content":"交互 一旦主线程绘制页面完成，你会认为我们已经“准备好了”，但事实并非如此。如果加载包括正确延迟加载的 JavaScript，并且仅在 onload 事件触发后执行，那么主线程可能会忙于执行脚本，无法用于滚动、触摸和其他交互操作。 可交互时间（TTI）是测量从第一个请求导致 DNS 查询和 SSL 连接到页面可交互时所用的时间——可交互是在首次内容绘制之后页面在 50ms 内响应用户的交互。如果主线程正在解析、编译和执行 JavaScript，则无法及时（小于 50ms）响应用户交互。 在我们的示例中，可能图像加载很快，但 anotherscript.js 文件的大小可能是 2MB，而且用户的网络连接很慢。在这种情况下，用户可以非常快地看到页面，但是在下载、解析和执行脚本之前，就无法滚动。这不是一个好的用户体验。避免占用主线程，如下面的网页测试示例所示： 在本例中，DOM 内容加载过程花费了超过 1.5 秒的时间，主线程在这段时间内完全被占用，对单击事件或屏幕点击没有响应。 ","date":"2024-06-06","objectID":"/posts/eb9e598/:6:0","tags":["Web"],"title":"渲染页面:浏览器的工作原理","uri":"/posts/eb9e598/"},{"categories":["draft"],"content":"博客（英语：Blog）是一种在线日记型式的个人网站，借由张帖子章、图片或视频来记录生活、抒发情感或分享信息。博客上的文章通常根据张贴时间，以倒序方式由新到旧排列。 胡超的第一篇博客 ","date":"2024-06-06","objectID":"/posts/583bc6c/:0:0","tags":["draft"],"title":"我的第一篇博客","uri":"/posts/583bc6c/"},{"categories":["Java"],"content":"使用 ElasticSearch(简称 es) 的过程中，经常有一些临时查询(如 排查问题、验证效果)，一个趁手的可视化工具 可以提高工作效率。个人倾向于 免费(最好开源)、易于安装(如 浏览器插件)，`es-client` 就是 比较简单好用的一个，尤其是 查询。","date":"2023-08-05","objectID":"/posts/elasticsearch-client-es-client-head/","tags":["Java","ElasticSearch","es"],"title":"简单好用的ElasticSearch可视化工具：es-client和Head","uri":"/posts/elasticsearch-client-es-client-head/"},{"categories":["Java"],"content":"一、前言 使用 ElasticSearch(简称 es) 的过程中，经常有一些临时查询(如 排查问题、验证效果)，一个趁手的可视化工具 可以提高工作效率。 个人倾向于 免费(最好开源)、易于安装(如 浏览器插件)，es-client 就是 比较简单好用的一个，尤其是 查询。 ","date":"2023-08-05","objectID":"/posts/elasticsearch-client-es-client-head/:1:0","tags":["Java","ElasticSearch","es"],"title":"简单好用的ElasticSearch可视化工具：es-client和Head","uri":"/posts/elasticsearch-client-es-client-head/"},{"categories":["Java"],"content":"二、Kibana es官方的可视化工具，天花板级别，当然也复杂一些，如要配置 Index Patterns 才能查询 7.11版本开始 需考虑许可证问题，也应该也是 阿里云es默认 7.10版本的原因吧，Kibana 提供给别人(如 公司的同事)使用收费 Kibana开源版 没有 性能分析工具 Search Profiler、Grok Debugger 等 ","date":"2023-08-05","objectID":"/posts/elasticsearch-client-es-client-head/:2:0","tags":["Java","ElasticSearch","es"],"title":"简单好用的ElasticSearch可视化工具：es-client和Head","uri":"/posts/elasticsearch-client-es-client-head/"},{"categories":["Java"],"content":"三、Head 系列 Head 多年前 刚接触es时，用的工具，浏览器插件 方式安装，简单方便，只能保存 1个集群的连接信息 集群、索引方面的功能可以，数据浏览、基本查询 功能偏弱 顶部 可以直观的看到 集群健康值，并以 颜色标识 主要分为：概览、索引、数据浏览、基本查询、符合查询，以及右上角的 信息 概览：页面是横向布局，可以直观的看到 集群节点列表，哪个是 主节点(最左侧 五角星标识)，索引的 分片、副本 分布在哪些节点 索引：列表，包含 名称、别名、创建时间、大小、文档数量、分片数、副本数。以前就根据 大小 清理过数据，可惜不支持排序 数据浏览：只能根据 索引、类型 筛选数据，不支持自定义条件，且 不能翻页，最多显示 50条数据 基本查询：还是不能翻页，可以选择显示 10、50、250、1000、5000、25000 条。索引、字段 下拉框 不支持 输入筛选，不太方便。查询条件不能 临时禁用，只能删除 复合查询：竟然还要输入 集群地址 Multi Elasticsearch Head 看名字就知道，是支持保存 多个集群连接信息的 Head 了 字体可能偏小，可以改插件的 css样式调整 es有密码的情况下，每次重启浏览器以后，重新连接都需要输入 用户名、密码 ","date":"2023-08-05","objectID":"/posts/elasticsearch-client-es-client-head/:3:0","tags":["Java","ElasticSearch","es"],"title":"简单好用的ElasticSearch可视化工具：es-client和Head","uri":"/posts/elasticsearch-client-es-client-head/"},{"categories":["Java"],"content":"四、es-client 数据浏览、基础查询 功能好用，开源免费，作者响应也比较及时 有 浏览器、utools、vscode、IDEA 插件版本，还有 windows安装包 支持保存 多个集群连接信息，重启浏览器重新连接 也不用输入 用户名、密码，更方便了 主要分为：概览、数据浏览、基础搜索、高级搜索、设置，以及右上角的 信息 概览 支持 索引名称、状态 筛选，按 名称、大小、文档数量 正序、倒序 排列，排查大索引 更方便了呀 数据浏览 输入类似SQL的 查询条件、排序，有时候更高效。 还用 _id=null 排查过数据同步的问题。 基础搜索 查询条件、排序 支持禁用，便于调整。 高级搜索 注意：输入请求内容，才显示 执行 按钮 设置 支持 排除指定索引，显示指定索引，本人贡献的PR，索引比较多 而 关注的索引不多时，可以大幅降低 干扰 ","date":"2023-08-05","objectID":"/posts/elasticsearch-client-es-client-head/:4:0","tags":["Java","ElasticSearch","es"],"title":"简单好用的ElasticSearch可视化工具：es-client和Head","uri":"/posts/elasticsearch-client-es-client-head/"},{"categories":["Java"],"content":"五、总结 es-client、Head 更适合个人使用，其中 es-client 在 数据浏览、基础搜索、索引过滤 3方面明显更优，Head 在 集群健康度、索引分片副本分布 显示方面更好 Kibana 更适合企业级使用，功能多，使用门槛高也一些。如配置好 时间字段，可以方便的 使用日期选择器筛选，还有 性能分析工具 Search Profiler、Grok Debugger 等，但是 7.11版本开始 需考虑许可证问题 我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=2p6eldem07gg4 本文遵守【CC BY-NC】协议，转载请保留原文出处及本版权声明，否则将追究法律责任。 本文首先发布于 https://www.890808.xyz/ ，其他平台需要审核更新慢一些。 ","date":"2023-08-05","objectID":"/posts/elasticsearch-client-es-client-head/:5:0","tags":["Java","ElasticSearch","es"],"title":"简单好用的ElasticSearch可视化工具：es-client和Head","uri":"/posts/elasticsearch-client-es-client-head/"},{"categories":["http","性能"],"content":"开发接口以后，对性能有要求的 接口，需要做 性能压力测试。常见免费的如：经典的 ab，性能不太好的 jmeter、siege(有时候都怀疑程序性能不行了)，另介绍 hey、k6、vegeta、wrk","date":"2023-07-18","objectID":"/posts/http-api-benchmarking-load-testing/","tags":["http","性能","测试"],"title":"HTTP接口性能压力测试","uri":"/posts/http-api-benchmarking-load-testing/"},{"categories":["http","性能"],"content":"一、前言 开发接口以后，对性能有要求的 接口，需要做 性能压力测试 常见免费的如：经典的 ab，性能不太好的 jmeter、siege(有时候都怀疑程序性能不行了)，另介绍 hey、k6、vegeta、wrk ","date":"2023-07-18","objectID":"/posts/http-api-benchmarking-load-testing/:1:0","tags":["http","性能","测试"],"title":"HTTP接口性能压力测试","uri":"/posts/http-api-benchmarking-load-testing/"},{"categories":["http","性能"],"content":"二、方案 ","date":"2023-07-18","objectID":"/posts/http-api-benchmarking-load-testing/:2:0","tags":["http","性能","测试"],"title":"HTTP接口性能压力测试","uri":"/posts/http-api-benchmarking-load-testing/"},{"categories":["http","性能"],"content":"1. ab - Apache HTTP server benchmarking tool C语言开发，适用于 Linux 平台 优劣：可能因为在 WSL里面运行，性能表现不太好，容易报错，apr_pollset_poll: The timeout specified has expired (70007) 参数：c 并发数、n 总请求数、k 表示 开启 Keep Alive 特性、r 表示 忽略 socket receive errors ab -c 100 -k -r -n 10000 http://www.a.com/a ","date":"2023-07-18","objectID":"/posts/http-api-benchmarking-load-testing/:2:1","tags":["http","性能","测试"],"title":"HTTP接口性能压力测试","uri":"/posts/http-api-benchmarking-load-testing/"},{"categories":["http","性能"],"content":"2. hey: HTTP load generator, ab replacement GO语言开发，适用于 Linux、Mac、Windows 平台 性能高，跨平台，报表显示慢请求原因，最近发版是 2020年 参数：c 并发数、z 测试时长 hey -c 50 -z 5s http://www.a.com/a ","date":"2023-07-18","objectID":"/posts/http-api-benchmarking-load-testing/:2:2","tags":["http","性能","测试"],"title":"HTTP接口性能压力测试","uri":"/posts/http-api-benchmarking-load-testing/"},{"categories":["http","性能"],"content":"3. jmeter Java语言开发，适用于 多 平台 优劣：性能较差，跨平台 ","date":"2023-07-18","objectID":"/posts/http-api-benchmarking-load-testing/:2:3","tags":["http","性能","测试"],"title":"HTTP接口性能压力测试","uri":"/posts/http-api-benchmarking-load-testing/"},{"categories":["http","性能"],"content":"4. k6：load testing tool, using Go and JS GO语言开发，适用于 Linux、Mac、Windows 平台 优劣：性能较高，跨平台，支持 请求、统计结果 校验，非常适合开发人员(复制略作调整即可)做接口自动化测试 参数：u 并发数、d 测试时长 需用 JavaScript 脚本 定义测试内容(如保存为 k6.js)，k6 run -u 200 -d 10s k6.js import http from \"k6/http\"; import { check, sleep } from \"k6\"; // Test configuration export const options = { }; export default function () { let res = http.get(\"url\"); // check(res, { \"status was 200\": (r) =\u003e r.status == 200 }); } ","date":"2023-07-18","objectID":"/posts/http-api-benchmarking-load-testing/:2:4","tags":["http","性能","测试"],"title":"HTTP接口性能压力测试","uri":"/posts/http-api-benchmarking-load-testing/"},{"categories":["http","性能"],"content":"5. siege C语言开发，适用于 Linux 平台 优劣：性能较低，不跨平台，报表没有显示慢请求原因 参数：c 并发数、t 测试时长(末尾单位必须大写)、b 表示 压测模式，请求不延迟(BENCHMARK: no delays between requests.) siege -c 200 -t 10S -b http://www.a.com/a ","date":"2023-07-18","objectID":"/posts/http-api-benchmarking-load-testing/:2:5","tags":["http","性能","测试"],"title":"HTTP接口性能压力测试","uri":"/posts/http-api-benchmarking-load-testing/"},{"categories":["http","性能"],"content":"6. vegeta GO语言开发，适用于 Linux、Mac、Windows 等5平台 优劣：性能高，跨平台，报表没有显示慢请求原因 参数：rate 指定并发，默认每秒 50个请求，0 表示不限制(用于测试接口极限性能，需和 max-workers 参数一起使用) 另 workers 参数 指定 初始 workers 数量，默认为 10，设置和 max-workers 相等可避免测试过程中创建连接耗时 echo \"GET http://www.a.com/a\" | vegeta attack -rate 0 -workers 200 -max-workers 200 -duration 10s | vegeta report ","date":"2023-07-18","objectID":"/posts/http-api-benchmarking-load-testing/:2:6","tags":["http","性能","测试"],"title":"HTTP接口性能压力测试","uri":"/posts/http-api-benchmarking-load-testing/"},{"categories":["http","性能"],"content":"7. wrk C语言开发，适用于 Linux 平台 优劣：性能超高，不跨平台，最近发版是 2021年2月，另WSL里面运行卡住停不下来 t 线程数(不宜过大，避免太多上下文切换，CPU核心数 1到3倍左右)，c 连接数，d 测试时长(末尾 s 表示秒)，latency 输出延迟统计 wrk -t12 -c100 -d10s --latency http://www.a.com/a ","date":"2023-07-18","objectID":"/posts/http-api-benchmarking-load-testing/:2:7","tags":["http","性能","测试"],"title":"HTTP接口性能压力测试","uri":"/posts/http-api-benchmarking-load-testing/"},{"categories":["http","性能"],"content":"三、总结 Open source load testing tool review 2020 (k6.io) 工具 RPS 开发语言 支持平台 备注 ab 1929 C Linux 可能因为在 WSL里面运行，性能不太好，容易报错 hey 12000 GO 3平台 性能高，跨平台，报表显示慢请求原因，最近发版是2020年 jmeter - Java 多平台 性能低，跨平台 k6 10000 GO 3平台 性能较高，跨平台，支持 请求、统计结果 校验，更适合自动化测试 siege 2253 C Linux 性能低，不跨平台，报表没有显示慢请求原因 vegeta 10400 GO 5平台 性能高，跨平台，报表没有显示慢请求原因 wrk - C Linux 性能超高，不跨平台，最近发版是 2021年2月，另WSL里面运行没有效果 本文遵守【CC BY-NC】协议，转载请保留原文出处及本版权声明，否则将追究法律责任。 本文首先发布于 https://www.890808.xyz/ ，其他平台需要审核更新慢一些。 ","date":"2023-07-18","objectID":"/posts/http-api-benchmarking-load-testing/:3:0","tags":["http","性能","测试"],"title":"HTTP接口性能压力测试","uri":"/posts/http-api-benchmarking-load-testing/"},{"categories":["Java","seatunnel"],"content":"免费支持 MySQL 实时同步到 ElasticSearch 的工具很少，Apache SeaTunnel 是一个高性能开源大数据集成工具，提供灵活易用、易扩展并支持千亿级数据集成的解决方案，已经在B站、腾讯云、字节等数百家公司使用。","date":"2023-07-04","objectID":"/posts/data-sync-apache-seatunnel/","tags":["Java","seatunnel","同步"],"title":"开源数据集成平台SeaTunnel：MySQL实时同步到es","uri":"/posts/data-sync-apache-seatunnel/"},{"categories":["Java","seatunnel"],"content":"一、前言 最近，项目有几个表要从 MySQL 实时同步到 另一个 MySQL，也有同步到 ElasticSearch 的。 目前，公司生产环境同步，用的是 阿里云的 DTS，每个同步任务每月 500多元，有点小贵。 其他环境：MySQL同步到ES，用的是 CloudCanal，不支持 数据转换，添加同步字段比较麻烦，社区版限制5个任务，不够用；MySQL同步到MySQL，用的是 debezium，不支持写入 ES。 恰好3年前用过 SeaTunnel 的 前身 WaterDrop，那就开始吧。本文以 2.3.1 版本，Ubuntu 系统为例 ","date":"2023-07-04","objectID":"/posts/data-sync-apache-seatunnel/:1:0","tags":["Java","seatunnel","同步"],"title":"开源数据集成平台SeaTunnel：MySQL实时同步到es","uri":"/posts/data-sync-apache-seatunnel/"},{"categories":["Java","seatunnel"],"content":"二、开源数据集成平台SeaTunnel ","date":"2023-07-04","objectID":"/posts/data-sync-apache-seatunnel/:2:0","tags":["Java","seatunnel","同步"],"title":"开源数据集成平台SeaTunnel：MySQL实时同步到es","uri":"/posts/data-sync-apache-seatunnel/"},{"categories":["Java","seatunnel"],"content":"1. 简介 SeaTunnel 是 Apache 软件基金会下的一个高性能开源大数据集成工具，为数据集成场景提供灵活易用、易扩展并支持千亿级数据集成的解决方案。 Seaunnel 为实时(CDC)和批量数据提供高性能数据同步能力，支持十种以上数据源，已经在B站、腾讯云、字节等数百家公司使用。 可以选择 SeaTunnel Zeta 引擎上运行，也可以在 Apache Flink 或 Spark 引擎上运行。 ","date":"2023-07-04","objectID":"/posts/data-sync-apache-seatunnel/:2:1","tags":["Java","seatunnel","同步"],"title":"开源数据集成平台SeaTunnel：MySQL实时同步到es","uri":"/posts/data-sync-apache-seatunnel/"},{"categories":["Java","seatunnel"],"content":"2. 安装 下载，这里选择 2.3.1 版本，执行 tar -xzvf apache-seatunnel-*.tar.gz 解压缩 因为 2.3.2 版本，MySQL-CDC 找不到驱动，bug修复详见 Caused by: java.sql.SQLException: No suitable driver at java.sql/java.sql.DriverManager.getDriver(DriverManager.java:298) at com.zaxxer.hikari.util.DriverDataSource.\u003cinit\u003e(DriverDataSource.java:106) ... 20 more ... 11 more at org.apache.seatunnel.engine.client.job.ClientJobProxy.waitForJobComplete(ClientJobProxy.java:122) at org.apache.seatunnel.core.starter.seatunnel.command.ClientExecuteCommand.execute(ClientExecuteCommand.java:181) ","date":"2023-07-04","objectID":"/posts/data-sync-apache-seatunnel/:2:2","tags":["Java","seatunnel","同步"],"title":"开源数据集成平台SeaTunnel：MySQL实时同步到es","uri":"/posts/data-sync-apache-seatunnel/"},{"categories":["Java","seatunnel"],"content":"3. 安装 connectors 插件 执行 bash bin/install-plugin.sh，国内建议先配置 maven 镜像，不然容易失败 或者 慢 官方文档写着执行 sh bin/install-plugin.sh，我在 Ubuntu 20.04.2 LTS 上执行报错(bin/install-plugin.sh: 54: Bad substitution)，我提了PR ","date":"2023-07-04","objectID":"/posts/data-sync-apache-seatunnel/:2:3","tags":["Java","seatunnel","同步"],"title":"开源数据集成平台SeaTunnel：MySQL实时同步到es","uri":"/posts/data-sync-apache-seatunnel/"},{"categories":["Java","seatunnel"],"content":"4. 编写配置文件 config 目录下，新建配置文件：如 mysql-es-test.conf 添加 env 配置 因为是 实时同步，这里 job.mode = “STREAMING”，execution.parallelism 是 并发数 env { # You can set flink configuration here execution.parallelism = 1 job.mode = \"STREAMING\" checkpoint.interval = 2000 #execution.checkpoint.interval = 10000 #execution.checkpoint.data-uri = \"hdfs://localhost:9000/checkpoint\" } MySQL 实时同步，需开启 binlog 添加 数据源 配置 result_table_name 取个 临时表名，便于后续使用。table-names 必须是 数据库.表名，base-url 必须指定 数据库。 startup.mode 默认是 INITIAL，先同步历史数据，后增量同步，详情点击 source { MySQL-CDC { result_table_name = \"t1\" server-id = 5656 username = \"root\" password = \"pwd\" table-names = [\"db.t1\"] base-url = \"jdbc:mysql://host:3306/db\" } } 添加 转换 配置，sql 比较灵活。 函数列表请点击 transform { Sql { source_table_name = \"t1\" query = \"SELECT id, alias_name aliasName FROM t1 WHERE c1 = '1'\" } } 添加 输出 配置 CDC 实时同步 es，必须配置 primary_keys sink { Elasticsearch { hosts = [\"host:9200\"] username = \"elastic\" password = \"pwd\" index = \"index_t1\" # cdc required options primary_keys = [\"id\"] } } 最终配置截图 ","date":"2023-07-04","objectID":"/posts/data-sync-apache-seatunnel/:2:4","tags":["Java","seatunnel","同步"],"title":"开源数据集成平台SeaTunnel：MySQL实时同步到es","uri":"/posts/data-sync-apache-seatunnel/"},{"categories":["Java","seatunnel"],"content":"5. 启动任务 这里以 本地模式为例，另有 集群、spark、flink 模式。 ./bin/seatunnel.sh -e local --config ./config/mysql-es-test.conf ","date":"2023-07-04","objectID":"/posts/data-sync-apache-seatunnel/:2:5","tags":["Java","seatunnel","同步"],"title":"开源数据集成平台SeaTunnel：MySQL实时同步到es","uri":"/posts/data-sync-apache-seatunnel/"},{"categories":["Java","seatunnel"],"content":"三、总结 开源数据集成平台SeaTunnel 能够比较方便的进行 MySQL 实时同步到 es 等，免费，还方便添加 同步字段。更多强大功能，请看官方文档。 新版本自带 同步引擎，不用依赖 spark、flink 等运行，降低了 小数据量同步场景 部署复杂度 新版本开始提供 UI界面，目前强依赖 调度平台 Apache DolphinScheduler 本文遵守【CC BY-NC】协议，转载请保留原文出处及本版权声明，否则将追究法律责任。 本文首先发布于 https://www.890808.xyz/ ，其他平台需要审核更新慢一些。 ","date":"2023-07-04","objectID":"/posts/data-sync-apache-seatunnel/:3:0","tags":["Java","seatunnel","同步"],"title":"开源数据集成平台SeaTunnel：MySQL实时同步到es","uri":"/posts/data-sync-apache-seatunnel/"},{"categories":["k8s"],"content":"Kubernetes(k8s) 环境中，应用 最大启动时长研究","date":"2023-05-23","objectID":"/posts/app-max-boot-time-on-k8s/","tags":["Kubernetes","k8s"],"title":"Kubernetes(k8s)最大启动时长研究","uri":"/posts/app-max-boot-time-on-k8s/"},{"categories":["k8s"],"content":"一、前言 应用部署在 Kubernetes(k8s)上，有些应用启动慢一些，没启动好 就又被 k8s 重启了 ","date":"2023-05-23","objectID":"/posts/app-max-boot-time-on-k8s/:1:0","tags":["Kubernetes","k8s"],"title":"Kubernetes(k8s)最大启动时长研究","uri":"/posts/app-max-boot-time-on-k8s/"},{"categories":["k8s"],"content":"二、处理过程 ","date":"2023-05-23","objectID":"/posts/app-max-boot-time-on-k8s/:2:0","tags":["Kubernetes","k8s"],"title":"Kubernetes(k8s)最大启动时长研究","uri":"/posts/app-max-boot-time-on-k8s/"},{"categories":["k8s"],"content":"1. 看日志 [2023-05-23 14:38:52.249]|-INFO |-[background-preinit]|-o.h.v.i.u.Version[0]|-[TID: N/A]|-HV000001: Hibernate Validator 6.1.7.Final [2023-05-23 14:40:11.817]|-INFO |-... 2023-05-23 14:40:22 登录主机: aaaa失败! 原因:Failed to upgrade to websocket: Unexpected HTTP Response Status Code: 500 Internal Server Error ","date":"2023-05-23","objectID":"/posts/app-max-boot-time-on-k8s/:2:1","tags":["Kubernetes","k8s"],"title":"Kubernetes(k8s)最大启动时长研究","uri":"/posts/app-max-boot-time-on-k8s/"},{"categories":["k8s"],"content":"2. 看探针配置 livenessProbe: failureThreshold: 3 initialDelaySeconds: 30 periodSeconds: 10 successThreshold: 1 tcpSocket: port: 60001 timeoutSeconds: 1 ","date":"2023-05-23","objectID":"/posts/app-max-boot-time-on-k8s/:2:2","tags":["Kubernetes","k8s"],"title":"Kubernetes(k8s)最大启动时长研究","uri":"/posts/app-max-boot-time-on-k8s/"},{"categories":["k8s"],"content":"3. 分析 刚开始以为 80秒左右(14:38:52.249 到 14:40:11.817)，应用被重启了 发现和 探针配置的不一样，initialDelaySeconds + periodSeconds * failureThreshold = 60秒 然后发现最终结束时间应该是 14:40:22 登录主机: aaaa失败，就是 90秒左右 最后发现还有个 宽限时长 terminationGracePeriodSeconds: 30，加上探针 60秒，刚好 90秒左右。至此终于 水落石出 建议运维把 initialDelaySeconds 改为 60 以后，成功启动 ","date":"2023-05-23","objectID":"/posts/app-max-boot-time-on-k8s/:2:3","tags":["Kubernetes","k8s"],"title":"Kubernetes(k8s)最大启动时长研究","uri":"/posts/app-max-boot-time-on-k8s/"},{"categories":["k8s"],"content":"三、总结 最长重启时间：initialDelaySeconds + (periodSeconds + timeoutSeconds) * failureThreshold + terminationGracePeriodSeconds(默认30秒) 建议 适当调大 initialDelaySeconds(如 60)、failureThreshold(如 6)、periodSeconds(如 20)，总之根据上面的公式计算的时长 要大于 实际启动时长(如 本地测试) 配置存活、就绪和启动探针 | Kubernetes kubernetes的三种探针startupprobe,ReadinessProbe,LivenessProbe记录 - 陈雷雷 - 博客园 (cnblogs.com) 本文首先发布于 https://www.890808.xyz/ ，其他平台需要审核更新慢一些。 ","date":"2023-05-23","objectID":"/posts/app-max-boot-time-on-k8s/:3:0","tags":["Kubernetes","k8s"],"title":"Kubernetes(k8s)最大启动时长研究","uri":"/posts/app-max-boot-time-on-k8s/"},{"categories":["Java"],"content":"ElasticSearch的Java客户端中，spring-data-elasticsearch 简化了 增删改、建索引等，没有简化 复杂查询 编码。easy-es API 类似 Mybatis-Plus，大幅降低开发门槛，减少代码量，支持 自定义排序、权重、原生查询，留下了 广阔的调整空间","date":"2023-04-05","objectID":"/posts/easy-es-cover-elasticsearch/","tags":["Java","ElasticSearch","es"],"title":"用easy-es简化ElasticSearch操作","uri":"/posts/easy-es-cover-elasticsearch/"},{"categories":["Java"],"content":"一、前言 ElasticSearch的Java客户端中，spring-data-elasticsearch 简化了 增删改、建索引等，没有简化 复杂查询 编码。easy-es API 类似 Mybatis-Plus，大幅降低开发门槛，减少代码量，支持 自定义排序、权重、原生查询，留下了 广阔的调整空间 ","date":"2023-04-05","objectID":"/posts/easy-es-cover-elasticsearch/:1:0","tags":["Java","ElasticSearch","es"],"title":"用easy-es简化ElasticSearch操作","uri":"/posts/easy-es-cover-elasticsearch/"},{"categories":["Java"],"content":"二、Java客户端 Java Transport Client：官方已弃用，二进制协议，版本强绑定，不建议使用 Jest：4年多没发布新版本，不维护了，不建议使用 Java REST Client：7.15 以下版本适用 Elasticsearch Java API Client：7.16 版本发布测试版，建议es 8.0 以上使用 spring-data-elasticsearch：简化了 增删改、建索引等，没有简化 复杂查询 编码 easy-es：API 类似 Mybatis-Plus，大幅降低开发门槛，减少代码量，支持 自定义排序、权重、原生查询，留下了 广阔的调整空间 ","date":"2023-04-05","objectID":"/posts/easy-es-cover-elasticsearch/:2:0","tags":["Java","ElasticSearch","es"],"title":"用easy-es简化ElasticSearch操作","uri":"/posts/easy-es-cover-elasticsearch/"},{"categories":["Java"],"content":"三、easy-es MySQL和 easy-es 语法对比 | Easy-Es MySQL Easy-Es es-DSL/es java api and and must or or should = eq term != ne boolQueryBuilder.mustNot(queryBuilder) \u003e gt QueryBuilders.rangeQuery(’es field’).gt() \u003e= ge .rangeQuery(’es field’).gte() \u003c lt .rangeQuery(’es field’).lt() \u003c= le .rangeQuery(’es field’).lte() like ‘%field%’ like QueryBuilders.wildcardQuery(field,value) … spring-boot配置 注意：adress 不能以 http(s):// 开头 在 application.yml 配置文件中添加： easy-es: enable: true # 是否开启EE自动配置 默认开启,可缺省 address: 域名:9200 username: elastic password: 密码 banner: false # 默认为true 打印banner 若您不期望打印banner,可配置为false global-config: process-index-mode: smoothly #索引处理模式,smoothly:平滑模式,默认开启此模式, not_smoothly:非平滑模式, manual:手动模式 print-dsl: false # 开启控制台打印通过本框架生成的DSL语句，默认为开启，测试稳定后的生产环境建议关闭，以提升少量性能 async-process-index-blocking: false # 异步处理索引是否阻塞主线程 默认阻塞 数据量过大时调整为非阻塞异步进行 项目启动更快 db-config: table-prefix: # 索引前缀,可用于区分环境 默认为空 用法和MP的tablePrefix一样的作用和用法 field-strategy: not_null # 字段更新策略 默认为not_null refresh-policy: none # 默认为不刷新，wait_until对写入性能影响也很大 添加依赖 如 maven，以 1.1.1 版本为例(最新版本是 2.0.0-beta1，后续讨论)： \u003cdependency\u003e \u003cgroupId\u003ecn.easy-es\u003c/groupId\u003e \u003cartifactId\u003eeasy-es-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.1.1\u003c/version\u003e \u003c/dependency\u003e 编写实体类 索引名称：默认是 类名转全小写(没有驼峰了)，建议驼峰类名指定 keepGlobalPrefix：配合全局配置 easy-es.global-config.db-config.table-prefix 实现多个环境公用es String类型字段，1.1.1 版本默认为 keyword，为了便于后续升级，建议指定 @Data @IndexName(value = \"document\", keepGlobalPrefix = true) public class Document { /** * es中的id */ private String id; /** * 文档标题 */ @IndexField(fieldType = FieldType.KEYWORD) private String title; /** * 文档内容 */ @IndexField(fieldType = FieldType.TEXT, analyzer = Analyzer.IK_SMART) private String content; } 编写Mapper类 public interface DocumentMapper extends BaseEsMapper\u003cDocument\u003e { } 添加 @EsMapperScan 注解 @SpringBootApplication @EsMapperScan(\"com.xpc.easyes.sample.mapper\") public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 保存 Document document = new Document(); document.setTitle(\"老汉\"); document.setContent(\"推*技术过硬\"); int successCount = documentMapper.insert(document); 更新 Document document1 = new Document(); document1.setId(\"id\"); document1.setTitle(\"title1\"); documentMapper.updateById(document1); 分页查询 documentMapper.pageQuery(EsWrappers.lambdaQuery(Document.class).eq(Document::getTitle, \"老汉\"), 1, 20) ","date":"2023-04-05","objectID":"/posts/easy-es-cover-elasticsearch/:3:0","tags":["Java","ElasticSearch","es"],"title":"用easy-es简化ElasticSearch操作","uri":"/posts/easy-es-cover-elasticsearch/"},{"categories":["Java"],"content":"四、总结 easy-es，大幅降低开发门槛，减少代码量，支持 自定义排序、权重、原生查询，留下了 广阔的调整空间 本文首先发布于 https://www.890808.xyz/ ，其他平台需要审核更新慢一些。 ","date":"2023-04-05","objectID":"/posts/easy-es-cover-elasticsearch/:4:0","tags":["Java","ElasticSearch","es"],"title":"用easy-es简化ElasticSearch操作","uri":"/posts/easy-es-cover-elasticsearch/"},{"categories":null,"content":"FixIt 主题的离线缓存页面","date":"0001-01-01","objectID":"/offline/","tags":null,"title":"","uri":"/offline/"},{"categories":null,"content":"FixIt 主题的友链模板 Demo","date":"0001-01-01","objectID":"/friends/","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":null,"content":" 添加您的 FixIt 网站 您可以通过 创建 PR 将您的 FixIt 网站添加到此页面。（例如：#111）  网站失效、停止维护、不当内容都可能被取消链接！ ","date":"0001-01-01","objectID":"/friends/:0:0","tags":null,"title":"友情链接","uri":"/friends/"}]